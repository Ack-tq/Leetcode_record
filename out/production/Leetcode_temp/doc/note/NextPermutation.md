---
题目要求在给定数组的前提下给出**循环字典排序**的下一组数组，也就是说例如输入为 `1，4，6，2，7`时，
输出为 `1，4，6，7，2` （题目还要求in place 排序）
###对于此题，我们要解决如下几个问题：  
    1、如何通过通过本数组给出下一个字典排序数组  
    2、当给定数组本来就是字典排序最后一位时，如何给出最小的字典排序  
    3、如何做到原地排序
###解决思路
- 排序的一项前提是原地排序，这意味着可以使用该方法进行排序
    ```
    //将数组nums第fromIndex到第toIndex-1位的元素不递减排序 
    Arrays.sort(int[] nums, int fromIndex, int toIndex)
    ```

- 下一个字典排序数组意味着对应于原数组最小的变化。思考普通数字寻找下一位的过程：
  例如 [1, 9, 2, 2, 4, 9, 7， 6, 2, 1]，下一位为 [1, 9, 2, 2, 6, 1, 2, 4, 7， 9]
  我们不会从左向右考虑考虑，尤其当数字很长而且像题目中是离散的随机数字组成的数组。从右向左
  考虑是最简单和方便的，就好比如最后两位是5和6的数组，我们不必考虑前面的一系列数字，直接将5和6互换位置
  便得到了字典排序的下一个数组。
- 对上面的例子进行分析，就是从最右侧的1开始向左扫描。第一个扫描到的是2，可是它比1大，不符合要求，第二次
  扫描到的是6，它比2大，也不符合要求……一直下去，直到找到5，它小于9，符合我们的要求，即5就是我们的目标位置。
  此时可以看出来，从5开始往后，9是最大的一位，且9的左边是小于它的数，右侧都是递减(假设数字相同包含在其中)且小于它的数。
  我们就在右侧中找到最小的、大于5的数，即6，与5交换。得到[1, 9, 2, 2, 6, 9, 7, 4, 2, 1]。最后将6右侧所有数字进行排序
，  所得即为我们的目标[1, 9, 2, 2, 6, 1, 2, 4, 7， 9]。
- 具体而言，从右向左扫描如果各值都是递增的，也就是说从i=length-1开始，在找到目标之前，这段子数组
  (从目标位置到原数组尾)已经是字典中最大的了。只有到了目标位置，即出现nums[i] < nums[i+1]时，此时
  从i开始到尾的子数组，已经是字典排序中目标位置i开始的最大数组了。此时这个子数组有个特征，就是原数组i+1位置
  (或者说子数组下标为1位置)的值是子数组中值最大的位，且右侧都是小于它的值。这时只要在第i位右侧找到最小的、大于第 i 位值的
  一位，并将其与第i位交换，并对交换后第i位右侧所有数字组成的子数组进行排序，即实现了我们的目标。
- 如果刚好数组是字典排序的最大数组，经过上面的操作后找不到目标位置i(i>=0)，于是可以用条件判断后将其直接使用Arrays.sort(nums, 0, nums.length-1)
  进行排序。

###实现的具体代码
```java
class Solution {
    public void nextPermutation(int[] nums) {
        int length = nums.length;
        if (length > 2) {
            for (int i = length - 2; i >= 0; i--) {
                if (nums[i] >= nums[i + 1]) {
                    continue;
                } else {
                    for (int j = length - 1; j >= i + 1; j--) {
                        if (nums[j] > nums[i]) {
                            swap(nums, i, j);
                            Arrays.sort(nums, i + 1, length);
                            return;
                        }
                    }
                }
            }
            //没找到目标位置，即为字典排序的最大情况，即可对整个数组进行排序
            Arrays.sort(nums, 0, length);
        } else {
            //当原数组长度小于等于2时，直接交换就是结果
            swap(nums, 0, length - 1);
        }
    }
    public void swap(int[] nums, int a, int b){
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }
}
```